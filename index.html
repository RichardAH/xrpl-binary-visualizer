<!DOCTYPE html>
<!--
XRPL serialized object format visualizer
Author: Richard Holland
Date: 6 October 2020
-->
<html>
    <head>
        <title>XRPL Binary Visualizer</title>

<style>
body {
    margin: 0;
    padding: 0;
}

div#errormsg {
    margin: 0em .8em 0.8em .8em;
    padding: 1em;
    border-radius: 5px;
    border: 1px solid red;
    display: none;
    color: #b72c00;
    font-weight:bold;
    font-family: monospace;
    padding-left: 1.4em;
}


.clickable:before {
    content: "ðŸ‘‰";
    color: black;
    cursor: pointer;
}

.clickable {
    cursor: pointer;
    background: rgb(43 3 244 / 9%);
    margin: 0.3em;
    line-height: 1.2em;
    padding-left: 0.2em;
    padding-right: 0.2em;
}

.tainput {
    width: calc(100vw - 2em);
    height: 20vh;
    margin: 1em;
    box-sizing: border-box;
    border-radius: 5px;
    border: 1px solid #9C27B0;
    padding: 1em;
}
.output {
    background: hsl(0 0% 98% / 1);
    margin: 0em .8em 0.8em .8em;
    padding: 1em;
    border: 1px solid #2196F3;
    border-radius: 5px;
    font-family: monospace;
    overflow-wrap: break-word;
}

.payloadhex.right {
    color: rgb(224 5 5);
}

.left {
    margin-right: 1em;
    border-right: 1px solid black;
    padding-right: 1em;
    font: small-caption;
    font-size: small;
    text-align: right;
    max-width: 20em;
    color: #673AB7;
    font-family: monospace;
    display: inline-block;
    width: 20em;
}

.right:before {
    content: "0x";
    font-weight: normal;
    color: #9e9e9e5e;
    margin-right: 0.1em;
}
.right {
    display: inline-block;
    text-align: left;
    font-family: monospace;
    font-weight: bold;
    color: hsl(227deg 100% 46%);
    vertical-align: top;
    text-indent: -1.3em;
    padding-left: 1.3em;
    word-break: break-word;
    width: calc(100vw - 35em);
}
.fieldtext:before {
    content: "Field-code";
    font-size: smaller;
    margin-right: 2em;
    color: orange;
    position: absolute;
    left: 2em;
}
.typetext:before {
    content: "Type-code";
    font-size: smaller;
    margin-right: 2em;
    color: orange;
    position: absolute;
    left: 2em;
}
.payloadtext:before {
    content: "Field-contents";
    font-size: smaller;
    margin-right: 2em;
    color: orange;
    position: absolute;
    left: 2em;
}
        .invalid {

        }

        .type {


        }

        .field {


        }

        .explain {

        }

        .payload {

        }

</style>
    <script>

        var parse_stack = [] // when using objects inside objects this is used, by run_

        var indent_level = 0

        var unknown_detected = false

        function print_error(c, out) {
            out.innerHTML += "<br/><div class='invalid left'>Invalid character</div><div class='invalid right'>" +
                c + "</div>";
        }

        let defs = false;
        let type_lookup = {};

        function process_defs()
        {
            for (let k in defs["FIELDS"])
            {
                const fe = defs["FIELDS"][k];
                const fe_type = fe[1].type;
                let fe_type_code = typeof(defs["TYPES"][fe_type]) == "undefined" ? -1 :
                            defs["TYPES"][fe_type];
                if (!(fe_type_code in type_lookup))
                    type_lookup[fe_type_code] = {};

                type_lookup[fe_type_code][fe[1].nth] = 
                {
                    name: fe[0],
                    vl: fe[1].isVLEncoded,
                    signing: fe[1].isSigningField
                };
            }
        }

        function strip(html)
        {
            let doc = new DOMParser().parseFromString(html, 'text/html');
           return doc.body.textContent || "";
        }

        function getDefJson(url)
        {
            fetch(url === undefined || (''+url).trim() == '' ? 'def.json' : strip(url))
            .then(function(response) {
                return response.json();
            })
            .then(function(jsonResponse) {
                defs = jsonResponse;
                process_defs();
            }).catch(e=>{
                console.log(e);
                return ugly("Could not load: " + strip(url));
            });
        }

        getDefJson(window.location.search.substr(1));


        function print_type(t, h, out) {
            
            let s = "Unknown";
            for (let k in defs["TYPES"])
            if (defs["TYPES"][k] == t)
            {
                s = k;
                break;
            }

            if (s == "Unknown")
                unknown_detected = true;

            s = s.replaceAll('Hash', 'UInt').toUpperCase();

            if (s.substr(0,2) == "ST")
                s = s.substr(2);

            out.innerHTML += "<br/><div style='margin-left: "+indent_level+"em' class='type'><div class='typetext left'><b>" + s
                + "</b></div><div class='typehex right'>" + h + "</div></div>"
        }

        function print_field(t, fc, h, out) {

            var s = "[[UNKNOWN_FIELD]]"

            if ((t in type_lookup) && (fc in type_lookup[t]))
                s = type_lookup[t][fc].name;
            else
                unknown_detected = true;

            out.innerHTML += "<br/><div style='margin-left: "+indent_level+"em' class='field'><div class='fieldtext left'><b>" + s +
                "</b></div><div class='fieldhex right'>" + h + "</div></div>"
        }

        function print_explain(h, msg, out, nnl) {
            out.innerHTML += (typeof(nnl) == "undefined" ? "" : "<br/>") +
                "<div class='explain' style='margin-left: "+indent_level+"em'><div class='explaintext left'>" + msg + "</div>" +
                "<div class='explainhex right'>" + h + "</div></div>";
        }

        function print_explain_payload(h, msg, out, nnl) {
            out.innerHTML += (typeof(nnl) == "undefined" ? "" : "<br/>") +
                "<div class='explain' style='margin-left: "+indent_level+"em'><div class='explaintext left'>" + msg + "</div>" +
                "<div class='payloadhex right'>" + h + "</div></div>";
        }

        function print_explain_payload_special(h, msg, out, nnl, breakdown) {
            out.innerHTML += (typeof(nnl) == "undefined" ? "" : "<br/>") +
                "<div class='explain' style='margin-left: "+indent_level+"em'><div class='explaintext left'>" + msg + "</div>" +
                "<div class='payloadhex right'>" + h + '<div style="font-weight: normal; color: purple; margin-left:3em;">' + breakdown + '</div></div></div>';
        }

        function print_payload(t, f, h, msg, out) {

            out.innerHTML +=  "<br/>" +
                "<div class='payload' style='margin-left: "+indent_level+"em'><div class='payloadtext left'>" + msg + "</div>" +
                "<div class='payloadhex right'>" + h + "</div></div>";

        }

        function inpele()
        {
            return document.getElementsByTagName("textarea")[0]
        }

        function errorele()
        {
            return document.getElementById("errormsg")
        }

        // these functions help report errors to the user
        function clear()
        {
            inpele().style.background = "white"
            var m = make_up_link()
            if (m == "")
            {
                errorele().innerHTML = ""
                errorele().style.display = "none"
            } else
            {
                errorele().innerHTML = m
                errorele().style.display = "block"
                errorele().style.background = "#ffffff"
                errorele().style.color = "#3F51B5"
                errorele().style.border = "1px solid blue";
            }
        }

        function good()
        {
            inpele().style.background = "#e0ffd7"
            var m = make_up_link()
            errorele().innerHTML = "Looks like a valid STObject. " + m
            errorele().style.display = "block"
            errorele().style.background = "#d7ffdc"
            errorele().style.color = "#3F51B5"
            errorele().style.border = "1px solid blue";

        }

        function bad(msg)
        {
            inpele().style.background = "#ffd7d7"
            errorele().style.background = "#ffd7d7"
            errorele().innerHTML = msg + make_up_link()
            errorele().style.display = "block"
            errorele().style.color = "#F44336"
            errorele().style.border = "1px solid red";
        }

        function make_up_link()
        {
            return ( parse_stack.length > 0 ? "<a class='clickable' onclick='pop_()'>Go up</a>" : "" )
        }

        function info(msg)
        {
            inpele().style.background = "#fafafa"
            errorele().style.background = "#fafafa"
            errorele().innerHTML = msg + make_up_link()
            errorele().style.display = "block"
            errorele().style.color = "#3F51B5"
            errorele().style.border = "1px solid blue";
        }

        function ugly(msg)
        {
            inpele().style.background = "#ffecd7"
            errorele().style.background = "#ffecd7"
            errorele().innerHTML = msg + make_up_link()
            errorele().style.display = "block"
            errorele().style.color = "#F44336"
            errorele().style.border = "1px solid red";
        }

        function run_(x)
        {
            parse_stack.push(inpele().value)
            inpele().value = x
            run(0, true)
        }

        function pop_()
        {
            if (parse_stack.length == 0)
            {
                console.log("could not pop, no elements on stack")
                return
            }

            const v = parse_stack[parse_stack.length-1]
            parse_stack.pop()
            inpele().value = v
            run(0, true)
        }

        // convert the leaf values in a json object to links that populate the decoder
        function convert_json_to_links(j)
        {
            Object.keys(j).forEach(function(key) {
                var t = typeof(j[key])
                if (t == "object")
                    j[key] = convert_json_to_links(j[key])
                else if (t == "string")
                {
                    var inp = j[key].replace(/\s/gi, '')
                    if (inp.match(/^[A-Fa-f0-9]+$/) || inp.match(/^[-A-Za-z0-9+/]*={0,3}$/))
                        j[key] = '<a class=vvvv~clickablevvvv~ onclick=vvvv~run_(~vvvv' + inp + '~vvvv)vvvv~>' + j[key] + '</a>'
                }
            })

            return j
        }

        function obj_to_html(j)
        {
            var t = JSON.stringify(j)
            if (!t.match(/vvvv~/) && !t.match(/~vvvv/))
            {
                j = convert_json_to_links(j)
                var s = JSON.stringify(j, null, 2)
                s = s.replaceAll("vvvv~", "'").replaceAll("~vvvv", '"').replaceAll('\n', '<br/>')
                s = s.replaceAll(/(<br\/> +)/g, (s, g)=>{ return g.replaceAll(' ', '&nbsp;'); })
                return s
            } else
            {
                var s = JSON.stringify(j, null, 2)
                s = s.replaceAll(/(<br\/> +)/g, (s, g)=>{ return g.replaceAll(' ', '&nbsp;'); })
                return s
            }
        }

        function run(depth, dontclearstack) {
            if (!defs)
                return ugly("No definitions loaded. Try attach ?def.json to the url");

            if (!dontclearstack) parse_stack = []


            const out = document.getElementsByClassName("output")[0]
            out.innerHTML = ""

            indent_level = 0

            var inp = inpele().value

            // do an analysis to see if it's actually base64

            if (inp == "")
                return clear()

            const inp_nospace = inp.replace(/\s/gi, '')

            if (inp_nospace[0] == '{')
            {
                // probably json
                try {
                    j = JSON.parse(inp)
                    out.innerHTML = obj_to_html(j)
                    return info("You entered json... Click a field!")

                } catch (e) {
                    console.log(e)
                    // do nothing
                }

            }

            if (!inp_nospace.match(/^[A-Fa-f0-9]+$/) && /* not hex */
                inp_nospace.match(/^[-A-Za-z0-9+/]*={0,3}$/)) /* and is base64 */
            {
                if (depth > 0) {
                    console.log("recusrive loop detected, stopping")
                    return
                }

                // probably base64, convert to hex
                const binstr = atob(inp.replace(/\s/gi, ''))
                try {
                    var j = JSON.parse(binstr)
                    out.innerHTML = obj_to_html(j)
                    return info("When decoding base64 I found it contained json... Click a field!")
                } catch (e)
                {
                    console.log(e)

                    inp = ""
                    for (var i = 0; i < binstr.length; ++i)
                    {
                        var hex = binstr.charCodeAt(i).toString(16)
                        if (hex.length < 2) hex = "0" + hex
                        inp += hex
                    }

                    document.getElementsByTagName("textarea")[0].value = inp
                    return run(depth + 1, true)
                }
            }

            if (!inp_nospace.match(/^[A-Fa-f0-9]+$/)) /* not hex */
            {
                return bad("Input was not base64 or hex, I don't know what to do with it...")
            }

            unknown_detected = false

            var negative_depth = false

            var state = 0;
            var to_accumulate = 0;

            var hexaccum = "";
            var vec_counter = 0;

            var lastnibble = 0;

            var st_type = 0;
            var st_field = 0;

            var field_hex = "";

            var array_depth = 0
            var object_depth = 0

            var amount_type = -1;
            var mantissa_carry = 0;
            var flags = 0;
            var i = 0
            for (i = 0; i < inp.length; ++i) {

                console.log("state: " + state)

                var nibble = 0;
                var ascii = inp.charCodeAt(i);
                if (ascii >= 48 && ascii <= 57) { // 0-9
                    nibble = ascii - 48
                } else if (ascii >= 65 && ascii <= 70) { // A-F
                    nibble = ascii - 65 + 10
                } else if (ascii >= 97 && ascii <= 102) { // a-f
                    nibble = ascii - 97 + 10
                } else if (ascii == 32 || ascii == 9 || ascii == 10 || ascii == 13) {
                    // whitepsace, skip
                    continue
                } else {
                    print_error(inp[i], out)
                    break;
                }


                if (state == 51) {

                    hexaccum += inp[i]
                    if (st_type == 6 && to_accumulate == -1 && (nibble & 8)) {
                        to_accumulate = 96 // non-xrp currency
                        amount_type = 1
                    } else if (st_type == 6 && to_accumulate == -1 && (nibble & 8) == 0) {
                        to_accumulate = 16 // xrp currency
                        amount_type = 0
                    } else if (st_type == 8 && to_accumulate == 41) {
                        // accumulate the 2 VL nibbles at the start of the account field
                        print_explain(hexaccum, "account vl prefix", out)
                        if (hexaccum == '00')
                            to_accumulate = 1;
                        hexaccum = ""
                        amount_type = -1
                    }

                    to_accumulate--
                    if (amount_type == 0)
                    {
                        if (to_accumulate == 15)
                        {
                            let r = parseInt(hexaccum, 16) >>> 0;
                            r &= 0x3;
                            mantissa_carry = r;
                            r = r.toString(2);
                            if (r.length == 1) r = '0' + r;

                            print_explain_payload_special(hexaccum, "Flags", out, undefined,
                            '<span style="color:blue;">Bit </span>0 <small style="color:orange;">(XRP Bit)</small> '+
                            '1 <small style="color:orange;">(Sign Bit + Positve)</small> ' +
                            r + ' <small style="color:orange;">(First bits of drops integer)</small>'
                            );
                            hexaccum = ""
                        } else if (to_accumulate == 0)
                        {
                            print_explain_payload_special(hexaccum, "XRP Drops", out, undefined,
                             '<span style="color:blue;">Dec </span>' + (mantissa_carry + parseInt(hexaccum, 16))+
                                    ' <small style="color:orange;">(XRP Drops including two bits above)</small>'
                            );
                            amount_type = -1;
                            state = 0;
                        }
                    } else if (amount_type == 1)
                    {
                        if (to_accumulate == 93)
                        {
                            let firstthree = parseInt(hexaccum.slice(0,3), 16);
                            let bits = (firstthree >> 10);

                            let exponent_num = ((((firstthree >> 2)&0xFF)) >>> 0);
                            let exponent = exponent_num.toString(2);
                            if (exponent.length != 8) exponent = '0'.repeat(8 - exponent.length) + exponent;

                            print_explain_payload_special(hexaccum, "Flags + Exponent",
                                out, undefined,
                                '<span style="color:blue;">Bit </span>1 <small style="color:orange;">(Not XRP Bit)</small> ' +
                                    (bits & 1) + ' <small style="color:orange;">(' + ((bits & 1) ? 'Sign Bit + Positive' : 'Sign Bit - Negative') + ')</small> ' +
                                    exponent + ' <small style="color:orange;">(Exponent Raw: ' + exponent_num + ', Adujusted: '+(exponent_num-97)+')</small> ' +
                                (firstthree & 0x2) + (firstthree & 0x1) + ' <small style="color:orange;">(First two bits of mantissa)</small>');
                            mantissa_carry = (firstthree & 0x3) << 52;

                            hexaccum = "";
                        } else if (to_accumulate == 80)
                        {
                            print_explain_payload_special(hexaccum, "Mantissa", out, undefined, '<span style="color:blue;">Dec </span>' + (mantissa_carry + parseInt(hexaccum, 16))+
                                ' <small style="color:orange;">(Mantissa including two bits above)</small>');
                            hexaccum = "";
                        } else if (to_accumulate == 40)
                        {
                            let currency =
                                     String.fromCharCode(parseInt(hexaccum.slice(24,26), 16)) +
                                     String.fromCharCode(parseInt(hexaccum.slice(26,28), 16)) +
                                     String.fromCharCode(parseInt(hexaccum.slice(28,30), 16));
                            print_explain_payload_special(hexaccum, "Currency Code", out, undefined, '<span style="color:blue;">Asc </span>' + currency);
                            hexaccum = "";
                        } else if (to_accumulate == 0)
                        {
                            print_explain_payload(hexaccum, "Issuer", out);
                            hexaccum = "";
                            state = 0;
                            amount_type = -1;
                        }
                    } else if (amount_type == -1 && to_accumulate == 0) {
                        print_payload("", "", hexaccum, "&nbsp;", out)
                        state = 0
                    }
                    continue
                }

                if (state == 70) { // parsing a VL field
                    hexaccum = inp[i]
                    lastnibble = nibble
                    state = 71
                    continue
                }

                if (state == 71) {
                    hexaccum += inp[i]
                    var b = (lastnibble << 4) + nibble
                    if (b <= 192) {
                        to_accumulate = b*2
                        print_explain(hexaccum, "1 byte length " + b, out)
                        hexaccum = ""
                        if (to_accumulate == 0)
                            state = 0;
                        else
                            state = (st_type == 19 ? 190 : 51);
                        continue
                    } else if (b >= 193 && b <= 240) {
                        to_accumulate = ((b - 193)*256) + 193
                        state = 72
                        continue
                    } else {
                        to_accumulate = 12481 + ((b - 241) * 65536)
                        state = 74
                        continue
                    }
                }

                if (state == 72) {
                    hexaccum += inp[i]
                    lastnibble = nibble
                    state = 73
                    continue
                }
                if (state == 73) {
                    hexaccum += inp[i]
                    var b = (lastnibble << 4) + nibble
                    to_accumulate += b
                    print_explain(hexaccum, "2 byte length " + to_accumulate , out)
                    to_accumulate *= 2
                    hexaccum = ""
                    state = (st_type == 19 ? 190 : 51)
                    continue
                }

                if (state == 74) {
                    hexaccum += inp[i]
                    lastnibble = nibble
                    state = 75
                    continue
                }
                if (state == 75) {
                    hexaccum += inp[i]
                    var b = (lastnibble << 4) + nibble
                    to_accumulate += b * 256
                    state = 76
                    continue
                }

                if (state == 76) {
                    hexaccum += inp[i]
                    lastnibble = nibble
                    state = 77
                    continue
                }
                if (state == 77) {
                    hexaccum += inp[i]
                    var b = (lastnibble << 4) + nibble
                    to_accumulate += b
                    print_explain(hexaccum, "3 byte length " + to_accumulate, out)
                    to_accumulate *= 2
                    hexaccum = ""
                    state = (st_type == 19 ? 190 : 51)
                    continue
                }


                if (state == 0) { // parsing type
                    if (nibble == 0) {
                        print_explain(inp[i], "type uncommon", out)
                        state = 1
                        continue
                    }

                    st_type = nibble // this is the case where it's a one nibble type
                    print_type(st_type, inp[i], out)
                    state = 4 // expect 4 bit field code
                    continue
                }

                if (state == 4) {
                    if (nibble == 0) {
                        print_explain(inp[i], "field uncommon", out)
                        state = 6
                        continue
                    }

                    st_field = nibble
                    print_field(st_type, nibble, inp[i], out)
                    state = 5 // state 5 is a fallthrough state so do not continue
                }

                if (state == 6) {
                    lastnibble = nibble; // store the high nibble of fieldcode
                    hexaccum = inp[i];
                    state = 61;
                    continue;
                }

                if (state == 61) {
                    hexaccum += inp[i];
                    st_field = (lastnibble << 4) + nibble
                    print_field(st_type, st_field, hexaccum, out);
                    state = 5; // both type code (4 bits) and field code (8 bits) parsed
                }



                if (state == 1) { // parsing type with first nibble = 0
                    if (nibble == 0) {
                        print_explain(inp[i], "both type and field uncommon", out)
                        state = 2 // expect 8 bit typecode next followed by 8 bit field code
                        continue
                    }

                    st_field = nibble // we cant print until we parse type
                    field_hex = inp[i];

                    state = 3 // except 8 bit typecode next, we still need to print field
                    continue
                }

                if (state == 3) { // expect 8 bit typecode
                    lastnibble = nibble; // store the high nibble of typecode
                    hexaccum = inp[i];
                    state = 31;
                    continue;
                }

                if (state == 31) {
                    hexaccum += inp[i];
                    st_type = (lastnibble << 4) + nibble
                    // we still need to print the field because it came first but we didnt know it until we had type
                    print_field(st_type, st_field, field_hex, out);
                    print_type(st_type, hexaccum, out);
                    state = 5; // both field code (4 bits) and type code (8 bits) parsed
                }

                if (state == 2) { // expect 8 bit typecode followed by 8 bit field code
                    lastnibble = nibble; // store the high nibble of typecode
                    hexaccum = inp[i];
                    state = 21;
                    continue;
                }

                if (state == 21) {
                    hexaccum += inp[i];
                    st_type = (lastnibble << 4) + nibble
                    print_type(st_type, hexaccum, out);
                    state = 22; // expect 8 bit field code
                    continue;
                }

                if (state == 22) {
                    lastnibble = nibble;
                    hexaccum = inp[i];
                    state = 23;
                    continue;
                }

                if (state == 23) {
                    hexaccum += inp[i];
                    st_field = (lastnibble << 4) + nibble;
                    print_field(st_type, st_field, hexaccum, out);
                    state = 5; // type and field read
                }

                if (state == 5) {

                    // now we process VL if any and print the field contents
                    hexaccum = ""

                    if (st_type == 1) to_accumulate = 4
                    else if (st_type == 2) to_accumulate = 8
                    else if (st_type == 3) to_accumulate = 16
                    else if (st_type == 4) to_accumulate = 32
                    else if (st_type == 5) to_accumulate = 64
                    else if (st_type == 6) {
                        to_accumulate = -1 /* special value because we need the next byte to know how big 16 or 96 */
                        amount_type = -1
                    }
                    else if (st_type == 7) {
                        state = 70
                        continue
                    }
                    else if (st_type == 8) to_accumulate = 42
                    else if (st_type == 14) {
                        if (st_field == 1) {
                                 object_depth-- // end of object
                                 indent_level -= 2
                                 if (object_depth < 0) negative_depth = true
                        } else {
                                 object_depth++
                                 indent_level += 2
                        }
                        state = 0
                        continue
                    }
                    else if (st_type == 15) {
                        if (st_field == 1) {
                                 array_depth-- // end of array
                                 indent_level -= 2
                                 if (array_depth < 0) negative_depth = true
                        } else {
                                 array_depth++
                                 indent_level += 2
                        }
                        state = 0
                        continue
                    }
                    else if (st_type == 16) to_accumulate = 2
                    else if (st_type == 17) to_accumulate = 40
                    else if (st_type == 18) {
                        indent_level += 2;
                        state = 180
                        continue
                    }
                    else if (st_type == 19) {
                        state = 70
                        continue
                    }
                    else {
                        print_error(inp[i], "not sure how to proceed with this type")
                        break
                    }


                    state = 51
                    continue
                }

                if (state == 190)
                {
                    // vector256
                    if (to_accumulate == 0)
                    {
                        state = 0
                        continue
                    }
                    hex_accum = ""
                    state = 191
                    vec_counter = 0
                }

                if (state == 191)
                {
                    if (to_accumulate % 64 == 0 && hex_accum != "")
                    {
                        print_payload("", "", hex_accum, "hash " + (vec_counter++), out);
                        hex_accum = ""
                    }
                    to_accumulate--;
                    hex_accum += inp[i]
                    if (to_accumulate <= 0)
                    {
                        print_payload("", "", hex_accum, "hash " + (vec_counter++), out);
                        hex_accum = ""
                        vec_counter = 0
                        state = 0
                        continue
                    }
                    console.log(inp[i], to_accumulate)
                    continue
                }

                if (state == 182)
                {   // pathset accountid or currency or issuer
                    console.log("182: " + to_accumulate)
                    to_accumulate--;
                    hex_accum += inp[i];
                    if (to_accumulate <= 0)
                        state = (flags == 0 ? 184 : 183 ); // fallthru
                    else
                        continue; 
                }

                if (state == 183)
                {   // display parsed field
                    if (flags & 0x01)
                    {
                        print_payload("", "", hex_accum, "account", out);
                        flags -= 0x01;
                    }
                    else if (flags & 0x10)
                    {
                        print_payload("", "", hex_accum, "currency", out);
                        flags -= 0x10;
                    }
                    else if (flags & 0x20)
                    {
                        print_payload("", "", hex_accum, "issuer", out);
                        flags -= 0x20;
                    }

                    if (flags > 0)
                    {
                        state = 182;
                        to_accumulate = 40;
                        hex_accum = "";
                        continue;
                    }

                    state = 184;
                    continue;
                }

                if (state == 184)
                {
                    lastnibble = nibble;
                    state = 185;
                    continue;
                }

                if (state == 185)
                {
                    // check if continue or end byte for path set
                    let byte = (lastnibble << 4) + nibble; 
                        
                    if (byte == 0x00)
                    {
                        // end byte
                        indent_level -= 4;
                        print_explain(inp[i-1] + '' + inp[i], "pathset end", out);
                        state = 0;
                        continue;
                    }
                    else if (byte == 0xff)
                    {
                        // continue byte
                        indent_level -= 2;
                        print_explain(inp[i-1] + '' + inp[i], "pathset continue", out);
                        state = 180;
                        continue;
                    }
                    else
                    {
                        // another path step
                        indent_level -= 2;
                        flags = byte;
                        state = 181; // fall through
                    }
                }
            
                if (state == 180)
                {   // pathset lead byte
                    lastnibble = nibble;
                    state = 181;
                    continue;
                }
                
                if (state == 181)
                {   // pathset second byte
                    flags = (lastnibble << 4) + nibble;
                    
                    print_explain(inp[i-1] + '' + inp[i], "step w/ " + (flags & 0x1 ? "account " : "") +
                        (flags & 0x10 ? "currency " : "") + (flags & 0x20 ? "issuer" : "" ) + "", out);
                    
                    let tmp = flags;
                    if (tmp == 0)
                        break;

                    if (tmp & 0x01)
                        tmp -= 0x01;

                    if (tmp & 0x10)
                        tmp -= 0x10;

                    if (tmp & 0x20)
                        tmp -= 0x20;
                    
                    if (tmp != 0)
                        break;

                    indent_level += 2;

                    hex_accum = "";
                    to_accumulate = 40;
                    state = 182;
                    continue;
                }


                print_error("?", "Unknown parsing state maybe something wasn't implemented yet? Report this!", out)
                break
            }

            if (!unknown_detected && i == inp.length &&
                object_depth == 0 && array_depth == 0 &&
                state == 0 && !negative_depth)
                return good()

            const indent_info =
                (object_depth != 0 ? " and one or more internal objects lacked a terminator" : "") +
                (array_depth != 0 ? " and one or more internal arrays lacked a terminator" : "") +
                (negative_depth ? " and one or more internal objects or arrays lacked a header" : "")

            inp = inp_nospace.toUpperCase()
            len = inp.length
            if (len == 66 || len == 64 ||
                len == 40)
                return ugly("Parser did not complete cleanly" + indent_info +
                (unknown_detected ? " and unknown fields were detected" : "" ) + " ...<br/>by the way this" +
                    (inp[0] == 'E' && inp[1] == 'D' && len == 66 ?
                    " is definitely a public key not an STObject" :
                    ( len == 66 ? "might be a public key." :
                    ( len == 40 ? "might be an AccountID.": "might be a hash." ))))
            if (unknown_detected)
                return ugly("Unknown fields detected " +
                            ( i == inp.length ? "" : "and parser did not end cleanly, ") + "either not an STObject or wrong definitions.json. Try adding: ?url-to-your-definitions.json to the current URL")

            return ugly("Parser did not complete cleanly" + indent_info + ", if this is an STObject it is incomplete.")
        }
    </script>
    </head>
    <body>
        <textarea onchange="run(0, false)" rows="5" class="tainput" placeholder="Paste your Rippled/XRPL related HEX/json/base64 here then click outside the box to decode."></textarea>
        <div id="errormsg"></div>
    <div class="output">
    </div>
    </body>
</html>
