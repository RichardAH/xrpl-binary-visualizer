<!DOCTYPE html>
<!--
XRPL serialized object format visualizer
Author: Richard Holland
Date: 6 October 2020
-->
<html>
    <head>
        <title>XRPL Binary Visualizer</title>

<style>
body {
    margin: 0;
    padding: 0;
}

div#errormsg {
    margin: 0em .8em 0.8em .8em;
    padding: 1em;        
    border-radius: 5px;
    border: 1px solid red;
    display: none;
    color: #b72c00;
    font-weight:bold;
    font-family: monospace;
    padding-left: 1.4em;
}


.clickable:before {
    content: "ðŸ‘‰";
    color: black;
    cursor: pointer;
}

.clickable {
    cursor: pointer;
    background: rgb(43 3 244 / 9%);
    margin: 0.3em;
    line-height: 1.2em;
    padding-left: 0.2em;
    padding-right: 0.2em;
}

.tainput {
    width: calc(100vw - 2em);
    height: 20vh;
    margin: 1em;
    box-sizing: border-box;
    border-radius: 5px;
    border: 1px solid #9C27B0;
    padding: 1em;
}
.output {
    background: hsl(0 0% 98% / 1);
    margin: 0em .8em 0.8em .8em;
    padding: 1em;
    border: 1px solid #2196F3;
    border-radius: 5px;
    font-family: monospace;
    overflow-wrap: break-word;
}

.payloadhex.right {
    color: rgb(224 5 5);
}

.left {
    margin-right: 1em;
    border-right: 1px solid black;
    padding-right: 1em;
    font: small-caption;
    font-size: small;
    text-align: right;
    max-width: 20em;
    color: #673AB7;
    font-family: monospace;
    display: inline-block;
    width: 20em;
}

.right:before {
    content: "0x";
    font-weight: normal;
    color: #9e9e9e5e;
    margin-right: 0.1em;
}
.right {
    display: inline-block;
    text-align: left;
    font-family: monospace;
    font-weight: bold;
    color: hsl(227deg 100% 46%);
    vertical-align: top;
    text-indent: -1.3em;
    padding-left: 1.3em;
    word-break: break-word;
    width: calc(100vw - 35em);
}
.fieldtext:before {
    content: "Field-code";
    font-size: smaller;
    margin-right: 2em;
    color: orange;
    position: absolute;
    left: 2em;
}
.typetext:before {
    content: "Type-code";
    font-size: smaller;
    margin-right: 2em;
    color: orange;
    position: absolute;
    left: 2em;
}
.payloadtext:before {
    content: "Field-contents";
    font-size: smaller;
    margin-right: 2em;
    color: orange;
    position: absolute;
    left: 2em;
}
        .invalid {

        }

        .type {


        }

        .field {


        }

        .explain {

        }

        .payload {

        }

</style>
    <script>

        var parse_stack = [] // when using objects inside objects this is used, by run_

        var indent_level = 0

        var unknown_detected = false

        function print_error(c, out) {
            out.innerHTML += "<br/><div class='invalid left'>Invalid character</div><div class='invalid right'>" + 
                c + "</div>"; 
        }

        function print_type(t, h, out) {
            var s = 'STI_UNKNOWN'
            if (t == -1) s="STI_DONE"
            else if (t == 0) s="STI_NOTPRESENT"
            else if (t == 1) s="STI_UINT16"
            else if (t == 2) s="STI_UINT32"
            else if (t == 3) s="STI_UINT64"
            else if (t == 4) s="STI_HASH128"
            else if (t == 5) s="STI_HASH256"
            else if (t == 6) s="STI_AMOUNT"
            else if (t == 7) s="STI_VL"
            else if (t == 8) s="STI_ACCOUNT"
            else if (t == 14) s="STI_OBJECT"
            else if (t == 15) s="STI_ARRAY"
            else if (t == 16) s="STI_UINT8"
            else if (t == 17) s="STI_HASH160"
            else if (t == 18) s="STI_PATHSET"
            else if (t == 19) s="STI_VECTOR256"
            else if (t == 10001) s="STI_TRANSACTION"
            else if (t == 10002) s="STI_LEDGERENTRY"
            else if (t == 10003) s="STI_VALIDATION"
            else if (t == 10004) s="STI_METADATA"
            else unknown_detected = true
            out.innerHTML += "<br/><div style='margin-left: "+indent_level+"em' class='type'><div class='typetext left'><b>" + s 
                + "</b></div><div class='typehex right'>" + h + "</div></div>"
        }

        function print_field(t, fc, h, out) {

            var s = "[[UNKNOWN_FIELD]]"
            if (t == 1) {
                if (fc == 1) s="LedgerEntryType"
                else if (fc == 2) s="TransactionType"
                else if (fc == 3) s="SignerWeight"
                else if (fc == 16) s="Version"
                else unknown_detected = true
            } else if (t == 2) {
                if (fc == 1) s="TransactionType"
                else if (fc == 2) s="Flags"
                else if (fc == 3) s="SourceTag"
                else if (fc == 4) s="Sequence"
                else if (fc == 5) s="PreviousTxnLgrSeq"
                else if (fc == 6) s="LedgerSequence"
                else if (fc == 7) s="CloseTime"
                else if (fc == 8) s="ParentCloseTime"
                else if (fc == 9) s="SigningTime"
                else if (fc == 10) s="Expiration"
                else if (fc == 11) s="TransferRate"
                else if (fc == 12) s="WalletSize"
                else if (fc == 13) s="OwnerCount"
                else if (fc == 14) s="DestinationTag"
                else if (fc == 16) s="HighQualityIn"
                else if (fc == 17) s="HighQualityOut"
                else if (fc == 18) s="LowQualityIn"
                else if (fc == 19) s="LowQualityOut"
                else if (fc == 20) s="QualityIn"
                else if (fc == 21) s="QualityOut"
                else if (fc == 22) s="StampEscrow"
                else if (fc == 23) s="BondAmount"
                else if (fc == 24) s="LoadFee"
                else if (fc == 25) s="OfferSequence"
                else if (fc == 26) s="FirstLedgerSequence"
                else if (fc == 27) s="LastLedgerSequence"
                else if (fc == 28) s="TransactionIndex"
                else if (fc == 29) s="OperationLimit"
                else if (fc == 30) s="ReferenceFeeUnits"
                else if (fc == 31) s="ReserveBase"
                else if (fc == 32) s="ReserveIncrement"
                else if (fc == 33) s="SetFlag"
                else if (fc == 34) s="ClearFlag"
                else if (fc == 35) s="SignerQuorum"
                else if (fc == 36) s="CancelAfter"
                else if (fc == 37) s="FinishAfter"
                else if (fc == 38) s="SignerListID"
                else if (fc == 39) s="SettleDelay"
                else if (fc == 40) s="HookStateCount"
                else if (fc == 41) s="HookReserveCount"
                else if (fc == 42) s="HookDataMaxSize"
                else if (fc == 43) s="EmitGeneration"                
                else unknown_detected = true
            } else if ( t == 3 ) {
                if (fc == 1) s="IndexNext"
                else if (fc == 2) s="IndexPrevious"
                else if (fc == 3) s="BookNode"
                else if (fc == 4) s="OwnerNode"
                else if (fc == 5) s="BaseFee"
                else if (fc == 6) s="ExchangeRate"
                else if (fc == 7) s="LowNode"
                else if (fc == 8) s="HighNode"
                else if (fc == 9) s="DestinationNode"
                else if (fc == 10) s="Cookie"
                else if (fc == 11) s="ServerVersion"
                else if (fc == 12) s="EmitBurden"
                else if (fc == 16) s="HookOn"
                else unknown_detected = true
            } else if ( t == 4 ) {
                if (fc == 1) s="EmailHash"
                else unknown_detected = true
            } else if ( t == 5 ) {
                if (fc == 1) s="LedgerHash"
                else if (fc == 2) s="ParentHash"
                else if (fc == 3) s="TransactionHash"
                else if (fc == 4) s="AccountHash"
                else if (fc == 5) s="PreviousTxnID"
                else if (fc == 6) s="LedgerIndex"
                else if (fc == 7) s="WalletLocator"
                else if (fc == 8) s="RootIndex"
                else if (fc == 9) s="AccountTxnID"
                else if (fc == 10) s="EmitParentTxnID"
                else if (fc == 11) s="EmitNonce"
                else if (fc == 16) s="BookDirectory"
                else if (fc == 17) s="InvoiceID"
                else if (fc == 18) s="Nickname"
                else if (fc == 19) s="Amendment"
                else if (fc == 20) s="TicketID"
                else if (fc == 21) s="Digest"
                else if (fc == 22) s="Channel"
                else if (fc == 23) s="ConsensusHash"
                else if (fc == 24) s="CheckID"
                else if (fc == 25) s="ValidatedHash"
                else if (fc == 257) s="hash"
                else if (fc == 258) s="index"
                else unknown_detected = true
            } else if ( t == 6 ) {
                if (fc == 1) s="Amount"
                else if (fc == 2) s="Balance"
                else if (fc == 3) s="LimitAmount"
                else if (fc == 4) s="TakerPays"
                else if (fc == 5) s="TakerGets"
                else if (fc == 6) s="LowLimit"
                else if (fc == 7) s="HighLimit"
                else if (fc == 8) s="Fee"
                else if (fc == 9) s="SendMax"
                else if (fc == 10) s="DeliverMin"
                else if (fc == 16) s="MinimumOffer"
                else if (fc == 17) s="RippleEscrow"
                else if (fc == 18) s="DeliveredAmount"
                else unknown_detected = true
            } else if ( t == 7 ) {
                if (fc == 1) s="PublicKey"
                else if (fc == 2) s="MessageKey"
                else if (fc == 3) s="SigningPubKey"
                else if (fc == 4) s="TxnSignature"
                else if (fc == 6) s="Signature"
                else if (fc == 7) s="Domain"
                else if (fc == 8) s="FundCode"
                else if (fc == 9) s="RemoveCode"
                else if (fc == 10) s="ExpireCode"
                else if (fc == 11) s="CreateCode"
                else if (fc == 12) s="MemoType"
                else if (fc == 13) s="MemoData"
                else if (fc == 14) s="MemoFormat"
                else if (fc == 16) s="Fulfillment"
                else if (fc == 17) s="Condition"
                else if (fc == 18) s="MasterSignature"
                else if (fc == 19) s="UNLModifyValidator"
                else if (fc == 20) s="ValidatorToDisable"
                else if (fc == 21) s="ValidatorToReEnable"
                else if (fc == 22) s="HookData"
                else unknown_detected = true
            } else if ( t == 8 ) {
                if (fc == 1) s="Account"
                else if (fc == 2) s="Owner"
                else if (fc == 3) s="Destination"
                else if (fc == 4) s="Issuer"
                else if (fc == 5) s="Authorize"
                else if (fc == 6) s="Unauthorize"
                else if (fc == 7) s="Target"
                else if (fc == 8) s="RegularKey"
                else if (fc == 9) s="EmitCallback"
                else unknown_detected = true
            } else if ( t == 14 ) { /*STI_OBJECT*/
                if (fc == 1) s="End of Object"
                else if (fc == 2) s="TransactionMetaData"
                else if (fc == 3) s="CreatedNode"
                else if (fc == 4) s="DeletedNode"
                else if (fc == 5) s="ModifiedNode"
                else if (fc == 6) s="PreviousFields"
                else if (fc == 7) s="FinalFields"
                else if (fc == 8) s="NewFields"
                else if (fc == 9) s="TemplateEntry"
                else if (fc == 10) s="Memo"
                else if (fc == 11) s="SignerEntry"
                else if (fc == 12) s="EmitDetails"
                else if (fc == 16) s="Signer"
                else if (fc == 18) s="Majority"
                else if (fc == 19) s="DisabledValidator"                
                else unknown_detected = true
            } else if ( t == 15 ) { /*STI_ARRAY*/
                    if (fc == 1) s="End of Array"
                else if (fc == 3) s="Signers"
                else if (fc == 4) s="SignerEntries"
                else if (fc == 5) s="Template"
                else if (fc == 6) s="Necessary"
                else if (fc == 7) s="Sufficient"
                else if (fc == 8) s="AffectedNodes"
                else if (fc == 9) s="Memos"
                else if (fc == 16) s="Majorities"
                else if (fc == 17) s="NegativeUNL"                    
                else unknown_detected = true
            } else if ( t == 16 ) { //STI_UINT8
                if (fc == 1) s="CloseResolution"
                else if (fc == 2) s="Method"
                else if (fc == 3) s="TransactionResult"
                else if (fc == 16) s="TickSize"
                else if (fc == 17) s="UNLModifyDisabling"
                else unknown_detected = true
            } else if ( t == 17 ) { //STI_HASH160
                if (fc == 1) s="TakerPaysCurrency"
                else if (fc == 2) s="TakerPaysIssuer"
                else if (fc == 3) s="TakerGetsCurrency"
                else if (fc == 4) s="TakerGetsIssuer"
                else unknown_detected = true
            } else if ( t == 18 ) { //STI_PATHSET
                if (fc == 1) s="Paths"
                else unknown_detected = true
            } else if ( t == 19 ) { //STI_VECTOR256
                if (fc == 1) s="Indexes"
                else if (fc == 2) s="Hashes"
                else if (fc == 3) s="Amendments"
                else unknown_detected = true
            } else if ( t == 10001 ) { //STI_TRANSACTION
                if (fc == 257) s="Transaction"
                else unknown_detected = true
            } else if ( t == 10002 ) { //STI_LEDGERENTRY
                if (fc == 257) s="LedgerEntry"
                else unknown_detected = true
            } else if ( t == 10003 ) { //STI_VALIDATION
                if (fc == 257) s="Validation"
                else unknown_detected = true
            } else if ( t == 10004 ) { //STI_METADATA
                if (fc == 257) s="Metadata"
                else unknown_detected = true
            }
            out.innerHTML += "<br/><div style='margin-left: "+indent_level+"em' class='field'><div class='fieldtext left'><b>" + s +
                "</b></div><div class='fieldhex right'>" + h + "</div></div>"
        }
        
        function print_explain(h, msg, out, nnl) {
            out.innerHTML += (typeof(nnl) == "undefined" ? "" : "<br/>") + 
                "<div class='explain' style='margin-left: "+indent_level+"em'><div class='explaintext left'>" + msg + "</div>" +
                "<div class='explainhex right'>" + h + "</div></div>";
        }
        
        function print_explain_payload(h, msg, out, nnl) {
            out.innerHTML += (typeof(nnl) == "undefined" ? "" : "<br/>") + 
                "<div class='explain' style='margin-left: "+indent_level+"em'><div class='explaintext left'>" + msg + "</div>" +
                "<div class='payloadhex right'>" + h + "</div></div>";
        }
        
        function print_explain_payload_special(h, msg, out, nnl, breakdown) {
            out.innerHTML += (typeof(nnl) == "undefined" ? "" : "<br/>") + 
                "<div class='explain' style='margin-left: "+indent_level+"em'><div class='explaintext left'>" + msg + "</div>" +
                "<div class='payloadhex right'>" + h + '<div style="font-weight: normal; color: purple; margin-left:3em;">' + breakdown + '</div></div></div>';
        }

        function print_payload(t, f, h, msg, out) {

            out.innerHTML +=  "<br/>" + 
                "<div class='payload' style='margin-left: "+indent_level+"em'><div class='payloadtext left'>" + msg + "</div>" +
                "<div class='payloadhex right'>" + h + "</div></div>";

        }

        function inpele()
        {
            return document.getElementsByTagName("textarea")[0]
        }

        function errorele()
        {
            return document.getElementById("errormsg")
        }

        // these functions help report errors to the user
        function clear()
        {
            inpele().style.background = "white"
            var m = make_up_link()
            if (m == "")
            {
                errorele().innerHTML = ""
                errorele().style.display = "none"
            } else 
            {
                errorele().innerHTML = m
                errorele().style.display = "block"
                errorele().style.background = "#ffffff"
                errorele().style.color = "#3F51B5"
                errorele().style.border = "1px solid blue";
            }
        }

        function good()
        {
            inpele().style.background = "#e0ffd7"
            var m = make_up_link()
            errorele().innerHTML = "Looks like a valid STObject. " + m
            errorele().style.display = "block"
            errorele().style.background = "#d7ffdc"
            errorele().style.color = "#3F51B5"
            errorele().style.border = "1px solid blue";

        }

        function bad(msg)
        {
            inpele().style.background = "#ffd7d7"
            errorele().style.background = "#ffd7d7"
            errorele().innerHTML = msg + make_up_link()
            errorele().style.display = "block"
            errorele().style.color = "#F44336"
            errorele().style.border = "1px solid red";
        }

        function make_up_link()
        {
            return ( parse_stack.length > 0 ? "<a class='clickable' onclick='pop_()'>Go up</a>" : "" )
        }

        function info(msg) 
        {
            inpele().style.background = "#fafafa"
            errorele().style.background = "#fafafa"
            errorele().innerHTML = msg + make_up_link()
            errorele().style.display = "block"
            errorele().style.color = "#3F51B5"
            errorele().style.border = "1px solid blue";
        }

        function ugly(msg)
        {
            inpele().style.background = "#ffecd7"
            errorele().style.background = "#ffecd7"
            errorele().innerHTML = msg + make_up_link()
            errorele().style.display = "block"
            errorele().style.color = "#F44336"
            errorele().style.border = "1px solid red";
        }

        function run_(x)
        {
            parse_stack.push(inpele().value)
            inpele().value = x
            run(0, true)
        }

        function pop_()
        {
            if (parse_stack.length == 0) 
            {
                console.log("could not pop, no elements on stack")
                return
            }

            const v = parse_stack[parse_stack.length-1]
            parse_stack.pop()
            inpele().value = v
            run(0, true)
        }

        // convert the leaf values in a json object to links that populate the decoder
        function convert_json_to_links(j)
        {
            Object.keys(j).forEach(function(key) {
                var t = typeof(j[key])
                if (t == "object")
                    j[key] = convert_json_to_links(j[key])
                else if (t == "string") 
                {
                    var inp = j[key].replace(/\s/gi, '')
                    if (inp.match(/^[A-Fa-f0-9]+$/) || inp.match(/^[-A-Za-z0-9+/]*={0,3}$/))
                        j[key] = '<a class=vvvv~clickablevvvv~ onclick=vvvv~run_(~vvvv' + inp + '~vvvv)vvvv~>' + j[key] + '</a>'
                }
            })

            return j
        }

        function obj_to_html(j)
        {
            var t = JSON.stringify(j)
            if (!t.match(/vvvv~/) && !t.match(/~vvvv/))
            {
                j = convert_json_to_links(j)
                var s = JSON.stringify(j, null, 2)
                s = s.replaceAll("vvvv~", "'").replaceAll("~vvvv", '"').replaceAll('\n', '<br/>')
                s = s.replaceAll(/(<br\/> +)/g, (s, g)=>{ return g.replaceAll(' ', '&nbsp;'); }) 
                return s 
            } else
            {
                var s = JSON.stringify(j, null, 2)
                s = s.replaceAll(/(<br\/> +)/g, (s, g)=>{ return g.replaceAll(' ', '&nbsp;'); }) 
                return s 
            }
        }

        function run(depth, dontclearstack) {
            if (!dontclearstack) parse_stack = []


            const out = document.getElementsByClassName("output")[0]
            out.innerHTML = ""

            indent_level = 0

            var inp = inpele().value

            // do an analysis to see if it's actually base64

            if (inp == "") 
                return clear()

            const inp_nospace = inp.replace(/\s/gi, '')

            if (inp_nospace[0] == '{')
            {
                // probably json
                try {
                    j = JSON.parse(inp)
                    out.innerHTML = obj_to_html(j)
                    return info("You entered json... Click a field!")

                } catch (e) {
                    console.log(e)
                    // do nothing
                }

            }

            if (!inp_nospace.match(/^[A-Fa-f0-9]+$/) && /* not hex */
                inp_nospace.match(/^[-A-Za-z0-9+/]*={0,3}$/)) /* and is base64 */
            {
                if (depth > 0) {
                    console.log("recusrive loop detected, stopping")
                    return
                }

                // probably base64, convert to hex
                const binstr = atob(inp.replace(/\s/gi, ''))
                try {
                    var j = JSON.parse(binstr)
                    out.innerHTML = obj_to_html(j)
                    return info("When decoding base64 I found it contained json... Click a field!")
                } catch (e)
                {
                    console.log(e)

                    inp = ""
                    for (var i = 0; i < binstr.length; ++i) 
                    {
                        var hex = binstr.charCodeAt(i).toString(16)
                        if (hex.length < 2) hex = "0" + hex
                        inp += hex
                    }

                    document.getElementsByTagName("textarea")[0].value = inp
                    return run(depth + 1, true)
                }
            }

            if (!inp_nospace.match(/^[A-Fa-f0-9]+$/)) /* not hex */
            {
                return bad("Input was not base64 or hex, I don't know what to do with it...")
            }

            unknown_detected = false

            var negative_depth = false

            var state = 0;
            var to_accumulate = 0;

            var hexaccum = "";

            var lastnibble = 0;
        
            var st_type = 0;
            var st_field = 0;

            var field_hex = "";

            var array_depth = 0
            var object_depth = 0

            var amount_type = -1;
            var mantissa_carry = 0;
            var i = 0
            for (i = 0; i < inp.length; ++i) {

                var nibble = 0;
                var ascii = inp.charCodeAt(i);
                if (ascii >= 48 && ascii <= 57) { // 0-9
                    nibble = ascii - 48    
                } else if (ascii >= 65 && ascii <= 70) { // A-F
                    nibble = ascii - 65 + 10
                } else if (ascii >= 97 && ascii <= 102) { // a-f
                    nibble = ascii - 97 + 10
                } else if (ascii == 32 || ascii == 9 || ascii == 10 || ascii == 13) {
                    // whitepsace, skip
                    continue
                } else {
                    print_error(inp[i], out)
                    break;
                }
                

                if (state == 51) {

                    hexaccum += inp[i]
                    if (st_type == 6 && to_accumulate == -1 && (nibble & 8)) {
                        to_accumulate = 96 // non-xrp currency
                        amount_type = 1
                    } else if (st_type == 6 && to_accumulate == -1 && (nibble & 8) == 0) {
                        to_accumulate = 16 // xrp currency
                        amount_type = 0
                    } else if (st_type == 8 && to_accumulate == 41) {
                        // accumulate the 2 VL nibbles at the start of the account field
                        print_explain(hexaccum, "account vl prefix", out)
                        hexaccum = ""
                        amount_type = -1
                    }

                    to_accumulate--
                    if (amount_type == 0)
                    {
                        if (to_accumulate == 15)
                        {
                            let r = parseInt(hexaccum, 16) >>> 0;
                            r &= 0x3;
                            mantissa_carry = r;
                            r = r.toString(2);
                            if (r.length == 1) r = '0' + r;

                            print_explain_payload_special(hexaccum, "Flags", out, undefined,
                            '<span style="color:blue;">Bit </span>0 <small style="color:orange;">(XRP Bit)</small> '+ 
                            '1 <small style="color:orange;">(Sign Bit + Positve)</small> ' +
                            r + ' <small style="color:orange;">(First bits of drops integer)</small>'
                            );
                            hexaccum = ""
                        } else if (to_accumulate == 0)
                        {
                            print_explain_payload_special(hexaccum, "XRP Drops", out, undefined,
                             '<span style="color:blue;">Dec </span>' + (mantissa_carry + parseInt(hexaccum, 16))+
                                    ' <small style="color:orange;">(XRP Drops including two bits above)</small>'
                            );
                            amount_type = -1;
                            state = 0;
                        }
                    } else if (amount_type == 1)
                    {
                        if (to_accumulate == 93)
                        {
                            let firstthree = parseInt(hexaccum.slice(0,3), 16);
                            let bits = (firstthree >> 10);
                            
                            let exponent_num = ((((firstthree >> 2)&0xFF)) >>> 0);
                            let exponent = exponent_num.toString(2);
                            if (exponent.length != 8) exponent = '0'.repeat(8 - exponent.length) + exponent;

                            print_explain_payload_special(hexaccum, "Flags + Exponent",
                                out, undefined, 
                                '<span style="color:blue;">Bit </span>1 <small style="color:orange;">(Not XRP Bit)</small> ' +
                                    (bits & 1) + ' <small style="color:orange;">(' + ((bits & 1) ? 'Sign Bit + Positive' : 'Sign Bit - Negative') + ')</small> ' +
                                    exponent + ' <small style="color:orange;">(Exponent Raw: ' + exponent_num + ', Adujusted: '+(exponent_num-97)+')</small> ' + 
                                (firstthree & 0x2) + (firstthree & 0x1) + ' <small style="color:orange;">(First two bits of mantissa)</small>');
                            mantissa_carry = (firstthree & 0x3) << 52;

                            hexaccum = "";
                        } else if (to_accumulate == 80)
                        {
                            print_explain_payload_special(hexaccum, "Mantissa", out, undefined, '<span style="color:blue;">Dec </span>' + (mantissa_carry + parseInt(hexaccum, 16))+
                                ' <small style="color:orange;">(Mantissa including two bits above)</small>');
                            hexaccum = "";
                        } else if (to_accumulate == 40)
                        {
                            let currency =
                                     String.fromCharCode(parseInt(hexaccum.slice(24,26), 16)) +
                                     String.fromCharCode(parseInt(hexaccum.slice(26,28), 16)) +
                                     String.fromCharCode(parseInt(hexaccum.slice(28,30), 16));
                            print_explain_payload_special(hexaccum, "Currency Code", out, undefined, '<span style="color:blue;">Asc </span>' + currency);
                            hexaccum = "";
                        } else if (to_accumulate == 0)
                        {
                            print_explain_payload(hexaccum, "Issuer", out);
                            hexaccum = "";
                            state = 0;
                            amount_type = -1;
                        }
                    } else if (amount_type == -1 && to_accumulate == 0) {
                        print_payload(st_type, st_field, hexaccum, "&nbsp;", out)
                        state = 0
                    }
                    continue
                }

                if (state == 70) { // parsing a VL field
                    hexaccum = inp[i]
                    lastnibble = nibble
                    state = 71
                    continue
                }

                if (state == 71) {
                    hexaccum += inp[i]
                    var b = (lastnibble << 4) + nibble
                    if (b <= 192) {
                        to_accumulate = b*2
                        print_explain(hexaccum, "1 byte length " + b, out)
                        hexaccum = ""
                        if (to_accumulate == 0)
                            state = 0;
                        else
                            state = 51;
                        continue
                    } else if (b >= 193 && b <= 240) {
                        to_accumulate = ((b - 193)*256) + 193
                        state = 72
                        continue
                    } else {
                        to_accumulate = 12481 + ((b - 241) * 65536)
                        state = 74
                        continue
                    }
                }

                if (state == 72) {
                    hexaccum += inp[i]
                    lastnibble = nibble
                    state = 73
                    continue
                }
                if (state == 73) {
                    hexaccum += inp[i]
                    var b = (lastnibble << 4) + nibble
                    to_accumulate += b
                    print_explain(hexaccum, "2 byte length " + to_accumulate , out)
                    to_accumulate *= 2
                    hexaccum = ""
                    state = 51
                    continue
                }

                if (state == 74) {
                    hexaccum += inp[i]
                    lastnibble = nibble
                    state = 75
                    continue
                }
                if (state == 75) {
                    hexaccum += inp[i]
                    var b = (lastnibble << 4) + nibble
                    to_accumulate += b * 256
                    state = 76
                    continue
                }

                if (state == 76) {
                    hexaccum += inp[i]
                    lastnibble = nibble
                    state = 77
                    continue
                }
                if (state == 77) {
                    hexaccum += inp[i]
                    var b = (lastnibble << 4) + nibble
                    to_accumulate += b
                    print_explain(hexaccum, "3 byte length " + to_accumulate, out)
                    to_accumulate *= 2
                    hexaccum = ""
                    state = 51
                    continue
                }

           
                if (state == 0) { // parsing type
                    if (nibble == 0) {
                        print_explain(inp[i], "type uncommon", out)
                        state = 1
                        continue
                    }
                    
                    st_type = nibble // this is the case where it's a one nibble type
                    print_type(st_type, inp[i], out)
                    state = 4 // expect 4 bit field code
                    continue
                }

                if (state == 4) {
                    if (nibble == 0) {
                        print_explain(inp[i], "field uncommon", out)
                        state = 6
                        continue
                    }

                    st_field = nibble
                    print_field(st_type, nibble, inp[i], out)
                    state = 5 // state 5 is a fallthrough state so do not continue
                }
               
                if (state == 6) {
                    lastnibble = nibble; // store the high nibble of fieldcode
                    hexaccum = inp[i];
                    state = 61;
                    continue;
                }

                if (state == 61) {
                    hexaccum += inp[i];
                    st_field = (lastnibble << 4) + nibble
                    print_field(st_type, st_field, hexaccum, out);
                    state = 5; // both type code (4 bits) and field code (8 bits) parsed
                }



                if (state == 1) { // parsing type with first nibble = 0
                    if (nibble == 0) {
                        print_explain(inp[1], "both type and field uncommon", out)
                        state = 2 // expect 8 bit typecode next followed by 8 bit field code
                        continue
                    }

                    st_field = nibble // we cant print until we parse type
                    field_hex = inp[i];

                    state = 3 // except 8 bit typecode next, we still need to print field
                    continue
                }

                if (state == 3) { // expect 8 bit typecode
                    lastnibble = nibble; // store the high nibble of typecode
                    hexaccum = inp[i];
                    state = 31;
                    continue;
                }

                if (state == 31) {
                    hexaccum += inp[i];
                    st_type = (lastnibble << 4) + nibble
                    // we still need to print the field because it came first but we didnt know it until we had type
                    print_field(st_type, st_field, field_hex, out);
                    print_type(st_type, hexaccum, out);
                    state = 5; // both field code (4 bits) and type code (8 bits) parsed
                }

                if (state == 2) { // expect 8 bit typecode followed by 8 bit field code
                    lastnibble = nibble; // store the high nibble of typecode
                    hexaccum = inp[i];
                    state = 21;
                    continue;
                }

                if (state == 21) {
                    hexaccum += inp[i];
                    st_type = (lastnibble << 4) + nibble
                    print_type(st_type, hexaccum, out);
                    state = 22; // expect 8 bit field code
                    continue;
                }

                if (state == 22) {
                    lastnibble = nibble;
                    hexaccum = inp[i];
                    state = 23;
                    continue;
                }

                if (state == 23) {
                    hexaccum += inp[i];
                    st_field = (lastnibble << 4) + nibble;
                    print_field(st_type, st_field, hexaccum, out);
                    state = 5; // type and field read
                }
                
                if (state == 5) {

                    // now we process VL if any and print the field contents
                    hexaccum = ""

                    if (st_type == 1) to_accumulate = 4
                    else if (st_type == 2) to_accumulate = 8
                    else if (st_type == 3) to_accumulate = 16
                    else if (st_type == 4) to_accumulate = 32
                    else if (st_type == 5) to_accumulate = 64
                    else if (st_type == 6) {
                        to_accumulate = -1 /* special value because we need the next byte to know how big 16 or 96 */
                        amount_type = -1
                    }
                    else if (st_type == 7) {
                        state = 70
                        continue
                    }
                    else if (st_type == 8) to_accumulate = 42 
                    else if (st_type == 14) {
                        if (st_field == 1) {
                                 object_depth-- // end of object
                                 indent_level -= 2
                                 if (object_depth < 0) negative_depth = true
                        } else {
                                 object_depth++
                                 indent_level += 2
                        }
                        state = 0
                        continue
                    }
                    else if (st_type == 15) {
                        if (st_field == 1) {
                                 array_depth-- // end of array
                                 indent_level -= 2
                                 if (array_depth < 0) negative_depth = true
                        } else {
                                 array_depth++
                                 indent_level += 2
                        }
                        state = 0
                        continue
                    }
                    else if (st_type == 16) to_accumulate = 2
                    else if (st_type == 17) to_accumulate = 40
                    else if (st_type == 18) {
                        state = 180
                        continue
                    }
                    else if (st_type == 19) {
                        state = 190
                        continue
                    }
                    else {
                        print_error(inp[i], "not sure how to proceed with this type")
                        break
                    }
                    

                    state = 51
                    continue
                }

                print_error("?", "Unknown parsing state maybe something wasn't implemented yet? Report this!", out)
                break
            }

            if (!unknown_detected && i == inp.length && 
                object_depth == 0 && array_depth == 0 &&
                state == 0 && !negative_depth)
                return good()

            const indent_info = 
                (object_depth != 0 ? " and one or more internal objects lacked a terminator" : "") +
                (array_depth != 0 ? " and one or more internal arrays lacked a terminator" : "") + 
                (negative_depth ? " and one or more internal objects or arrays lacked a header" : "")

            inp = inp_nospace.toUpperCase()
            len = inp.length
            if (len == 66 || len == 64 || 
                len == 40)
                return ugly("Parser did not complete cleanly" + indent_info +
                (unknown_detected ? " and unknown fields were detected" : "" ) + " ...<br/>by the way this" + 
                    (inp[0] == 'E' && inp[1] == 'D' && len == 66 ? 
                    " is definitely a public key not an STObject" : 
                    ( len == 66 ? "might be a public key." :
                    ( len == 40 ? "might be an AccountID.": "might be a hash." ))))
            if (unknown_detected) 
                return ugly("Unknown fields detected " + 
                ( i == inp.length ? "" : "and parser did not end cleanly, ") + "probably not an STObject.")

            return ugly("Parser did not complete cleanly" + indent_info + ", if this is an STObject it is incomplete.")
        }
    </script>
    </head>
    <body>
        <textarea onchange="run(0, false)" rows="5" class="tainput" placeholder="Paste your Rippled/XRPL related HEX/json/base64 here then click outside the box to decode."></textarea>
        <div id="errormsg"></div>
    <div class="output">
    </div>
    </body>
</html>
